package fluxaorm

import "fmt"

func (g *codeGenerator) generateGetByID(schema *entitySchema, names *entityNames) {
	g.addLine(fmt.Sprintf("func (p %s) GetByID(ctx fluxaorm.Context, id uint64) (entity *%s, found bool, err error) {", names.providerNamePrivate, names.entityName))
	g.addLine("\tif cached := ctx.GetFromContextCache(p.cacheIndex, id); cached != nil {")
	g.addLine(fmt.Sprintf("\t\treturn cached.(*%s), true, nil", names.entityName))
	g.addLine("\t}")
	if schema.hasRedisCache {
		g.addLine("\tredisKey := p.redisCachePrefix + strconv.FormatUint(id, 10)")
		g.addLine("\tredisValues, err := ctx.Engine().Redis(p.redisCode).LRange(ctx, redisKey, 0, -1)")
		g.addLine("\tif err != nil {")
		g.addLine("\t\treturn nil, false, err")
		g.addLine("\t}")
		g.addLine("\tif len(redisValues) == 1 && redisValues[0] == \"\" {")
		g.addLine("\t\treturn nil, false, nil")
		g.addLine("\t}")
		g.addLine("\tif len(redisValues) > 1 && redisValues[0] == p.redisCacheStamp {")
		g.addLine(fmt.Sprintf("\t\te := &%s{ctx: ctx, id: id, originRedisValues: redisValues[1:]}", names.entityName))
		g.addLine("\t\tctx.SetInContextCache(p.cacheIndex, id, e)")
		g.addLine("\t\treturn e, true, nil")
		g.addLine("\t}")
	}
	g.appendToLine("\tquery := \"SELECT `ID`")
	for _, columnName := range schema.GetColumns()[1:] {
		g.appendToLine(",`" + columnName + "`")
	}
	g.addLine(fmt.Sprintf(" FROM `%s` WHERE `ID` = ? LIMIT 1\"", schema.tableName))
	g.addLine(fmt.Sprintf("\tsqlRow := &%s{}", names.sqlRowName))
	g.appendToLine(fmt.Sprintf("\tfound, err = ctx.Engine().DB(%s.dbCode).QueryRow(ctx, fluxaorm.NewWhere(query, id), &sqlRow.F0", names.providerName))
	for i := 1; i < len(schema.columnNames); i++ {
		g.appendToLine(fmt.Sprintf(", &sqlRow.F%d", i))
	}
	g.addLine(")")
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, false, err")
	g.addLine("\t}")
	g.addLine("\tif !found {")
	if schema.hasRedisCache {
		g.addLine("\t\tredisPipeline := ctx.RedisPipeLine(p.redisCode)")
		g.addLine("\t\tredisPipeline.Del(redisKey)")
		g.addLine("\t\tredisPipeline.RPush(redisKey, \"\")")
		g.addLine("\t\t_, err = redisPipeline.Exec(ctx)")
		g.addLine("\t\tif err != nil {")
		g.addLine("\t\t\treturn nil, false, err")
		g.addLine("\t\t}")
	}
	g.addLine("\t\treturn nil, false, nil")
	g.addLine("\t}")
	if schema.hasRedisCache {
		g.addLine("\t_, err = ctx.Engine().Redis(p.redisCode).RPush(ctx, redisKey, sqlRow.redisValues()...)")
		g.addLine("\tif err != nil {")
		g.addLine("\t\treturn nil, false, err")
		g.addLine("\t}")
	}
	g.addLine(fmt.Sprintf("\te := &%s{ctx: ctx, id: id, originDatabaseValues: sqlRow}", names.entityName))
	g.addLine("\tctx.SetInContextCache(p.cacheIndex, id, e)")
	g.addLine("\treturn e, true, nil")
	g.addLine("}")
	g.addLine("")
}

func (g *codeGenerator) generateGetByIDs(schema *entitySchema, names *entityNames) {
	g.addImport("strings")
	g.addImport("strconv")
	g.addLine(fmt.Sprintf("func (p %s) GetByIDs(ctx fluxaorm.Context, id ...uint64) ([]*%s, error) {", names.providerNamePrivate, names.entityName))
	g.addLine("\tif len(id) == 0 {")
	g.addLine("\t\treturn nil, nil")
	g.addLine("\t}")
	g.addLine(fmt.Sprintf("\tresultMap := make(map[uint64]*%s, len(id))", names.entityName))
	g.addLine("\tuniqueIDs := make([]uint64, 0, len(id))")
	g.addLine("\tfor _, v := range id {")
	g.addLine("\t\tif _, exists := resultMap[v]; !exists {")
	g.addLine("\t\t\tresultMap[v] = nil")
	g.addLine("\t\t\tuniqueIDs = append(uniqueIDs, v)")
	g.addLine("\t\t}")
	g.addLine("\t}")
	g.addLine("\tidsToFetch := make([]uint64, 0, len(uniqueIDs))")
	g.addLine("\tfor _, v := range uniqueIDs {")
	g.addLine("\t\tif cached := ctx.GetFromContextCache(p.cacheIndex, v); cached != nil {")
	g.addLine(fmt.Sprintf("\t\t\tresultMap[v] = cached.(*%s)", names.entityName))
	g.addLine("\t\t} else {")
	g.addLine("\t\t\tidsToFetch = append(idsToFetch, v)")
	g.addLine("\t\t}")
	g.addLine("\t}")
	selectPrefix := "SELECT `ID`"
	for _, columnName := range schema.GetColumns()[1:] {
		selectPrefix += ",`" + columnName + "`"
	}
	g.addLine("\tif len(idsToFetch) > 0 {")
	if schema.hasRedisCache {
		g.addLine("\t\tredisPipeline := ctx.RedisPipeLine(p.redisCode)")
		g.addLine("\t\tredisResults := make([]*fluxaorm.PipeLineSlice, len(idsToFetch))")
		g.addLine("\t\tfor i, v := range idsToFetch {")
		g.addLine("\t\t\tredisResults[i] = redisPipeline.LRange(p.redisCachePrefix+strconv.FormatUint(v, 10), 0, -1)")
		g.addLine("\t\t}")
		g.addLine("\t\t_, err := redisPipeline.Exec(ctx)")
		g.addLine("\t\tif err != nil {")
		g.addLine("\t\t\treturn nil, err")
		g.addLine("\t\t}")
		g.addLine("\t\tmissingIDs := make([]uint64, 0, len(idsToFetch))")
		g.addLine("\t\tfor i, v := range idsToFetch {")
		g.addLine("\t\t\tvalues, err := redisResults[i].Result()")
		g.addLine("\t\t\tif err != nil {")
		g.addLine("\t\t\t\treturn nil, err")
		g.addLine("\t\t\t}")
		g.addLine("\t\t\tif len(values) == 1 && values[0] == \"\" {")
		g.addLine("\t\t\t\tcontinue")
		g.addLine("\t\t\t}")
		g.addLine("\t\t\tif len(values) > 1 && values[0] == p.redisCacheStamp {")
		g.addLine(fmt.Sprintf("\t\t\t\te := &%s{ctx: ctx, id: v, originRedisValues: values[1:]}", names.entityName))
		g.addLine("\t\t\t\tresultMap[v] = e")
		g.addLine("\t\t\t\tctx.SetInContextCache(p.cacheIndex, v, e)")
		g.addLine("\t\t\t\tcontinue")
		g.addLine("\t\t\t}")
		g.addLine("\t\t\tmissingIDs = append(missingIDs, v)")
		g.addLine("\t\t}")
		g.addLine("\t\tif len(missingIDs) > 0 {")
		selectPrefixFull := selectPrefix + fmt.Sprintf(" FROM `%s` WHERE `ID` IN (", schema.tableName)
		g.addLine("\t\t\tvar b strings.Builder")
		g.addLine(fmt.Sprintf("\t\t\tb.WriteString(%q)", selectPrefixFull))
		g.addLine("\t\t\tb.WriteString(strconv.FormatUint(missingIDs[0], 10))")
		g.addLine("\t\t\tfor _, v := range missingIDs[1:] {")
		g.addLine("\t\t\t\tb.WriteByte(',')")
		g.addLine("\t\t\t\tb.WriteString(strconv.FormatUint(v, 10))")
		g.addLine("\t\t\t}")
		g.addLine("\t\t\tb.WriteByte(')')")
		g.addLine(fmt.Sprintf("\t\t\trows, cl, err := ctx.Engine().DB(%s.dbCode).Query(ctx, b.String())", names.providerName))
		g.addLine("\t\t\tif err != nil {")
		g.addLine("\t\t\t\treturn nil, err")
		g.addLine("\t\t\t}")
		g.addLine("\t\t\tdefer cl()")
		g.addLine("\t\t\tfoundInDB := make(map[uint64]bool, len(missingIDs))")
		g.addLine("\t\t\tcachePipeline := ctx.RedisPipeLine(p.redisCode)")
		g.addLine("\t\t\tfor rows.Next() {")
		g.addLine(fmt.Sprintf("\t\t\t\tsqlRow := &%s{}", names.sqlRowName))
		g.appendToLine("\t\t\t\terr = rows.Scan(ctx, &sqlRow.F0")
		for i := 1; i < len(schema.columnNames); i++ {
			g.appendToLine(fmt.Sprintf(", &sqlRow.F%d", i))
		}
		g.addLine(")")
		g.addLine("\t\t\t\tif err != nil {")
		g.addLine("\t\t\t\t\treturn nil, err")
		g.addLine("\t\t\t\t}")
		g.addLine(fmt.Sprintf("\t\t\t\te := &%s{ctx: ctx, id: sqlRow.F0, originDatabaseValues: sqlRow}", names.entityName))
		g.addLine("\t\t\t\tresultMap[sqlRow.F0] = e")
		g.addLine("\t\t\t\tfoundInDB[sqlRow.F0] = true")
		g.addLine("\t\t\t\tcachePipeline.RPush(p.redisCachePrefix+strconv.FormatUint(sqlRow.F0, 10), sqlRow.redisValues()...)")
		g.addLine("\t\t\t\tctx.SetInContextCache(p.cacheIndex, sqlRow.F0, e)")
		g.addLine("\t\t\t}")
		g.addLine("\t\t\tfor _, v := range missingIDs {")
		g.addLine("\t\t\t\tif !foundInDB[v] {")
		g.addLine("\t\t\t\t\tredisKey := p.redisCachePrefix + strconv.FormatUint(v, 10)")
		g.addLine("\t\t\t\t\tcachePipeline.Del(redisKey)")
		g.addLine("\t\t\t\t\tcachePipeline.RPush(redisKey, \"\")")
		g.addLine("\t\t\t\t}")
		g.addLine("\t\t\t}")
		g.addLine("\t\t\t_, err = cachePipeline.Exec(ctx)")
		g.addLine("\t\t\tif err != nil {")
		g.addLine("\t\t\t\treturn nil, err")
		g.addLine("\t\t\t}")
		g.addLine("\t\t}")
	} else {
		selectPrefix += fmt.Sprintf(" FROM `%s` WHERE `ID` IN (", schema.tableName)
		g.addLine("\t\tvar b strings.Builder")
		g.addLine(fmt.Sprintf("\t\tb.WriteString(%q)", selectPrefix))
		g.addLine("\t\tb.WriteString(strconv.FormatUint(idsToFetch[0], 10))")
		g.addLine("\t\tfor _, v := range idsToFetch[1:] {")
		g.addLine("\t\t\tb.WriteByte(',')")
		g.addLine("\t\t\tb.WriteString(strconv.FormatUint(v, 10))")
		g.addLine("\t\t}")
		g.addLine("\t\tb.WriteByte(')')")
		g.addLine(fmt.Sprintf("\t\trows, cl, err := ctx.Engine().DB(%s.dbCode).Query(ctx, b.String())", names.providerName))
		g.addLine("\t\tif err != nil {")
		g.addLine("\t\t\treturn nil, err")
		g.addLine("\t\t}")
		g.addLine("\t\tdefer cl()")
		g.addLine("\t\tfor rows.Next() {")
		g.addLine(fmt.Sprintf("\t\t\tsqlRow := &%s{}", names.sqlRowName))
		g.appendToLine("\t\t\terr = rows.Scan(ctx, &sqlRow.F0")
		for i := 1; i < len(schema.columnNames); i++ {
			g.appendToLine(fmt.Sprintf(", &sqlRow.F%d", i))
		}
		g.addLine(")")
		g.addLine("\t\t\tif err != nil {")
		g.addLine("\t\t\t\treturn nil, err")
		g.addLine("\t\t\t}")
		g.addLine(fmt.Sprintf("\t\t\te := &%s{ctx: ctx, id: sqlRow.F0, originDatabaseValues: sqlRow}", names.entityName))
		g.addLine("\t\t\tresultMap[sqlRow.F0] = e")
		g.addLine("\t\t\tctx.SetInContextCache(p.cacheIndex, sqlRow.F0, e)")
		g.addLine("\t\t}")
	}
	g.addLine("\t}")
	g.addLine(fmt.Sprintf("\tresult := make([]*%s, 0, len(uniqueIDs))", names.entityName))
	g.addLine("\tfor _, v := range uniqueIDs {")
	g.addLine("\t\tif e := resultMap[v]; e != nil {")
	g.addLine("\t\t\tresult = append(result, e)")
	g.addLine("\t\t}")
	g.addLine("\t}")
	g.addLine("\treturn result, nil")
	g.addLine("}")
	g.addLine("")
}

func (g *codeGenerator) generateNewMethods(schema *entitySchema, names *entityNames) {
	g.addLine(fmt.Sprintf("func (p %s) New(ctx fluxaorm.Context) *%s  {", names.providerNamePrivate, names.entityName))
	g.addLine(fmt.Sprintf("\treturn p.NewWithID(ctx, p.uuid(ctx))"))
	g.addLine("}")
	g.addLine("")
	g.addLine(fmt.Sprintf("func (p %s) NewWithID(ctx fluxaorm.Context, id uint64) *%s  {", names.providerNamePrivate, names.entityName))
	g.addLine(fmt.Sprintf("\te := &%s{ctx: ctx, new: true, id: id, originDatabaseValues: &%s{F0: id}}", names.entityName, names.sqlRowName))
	g.addLine(fmt.Sprintf("\te.ctx.Track(e, %s.cacheIndex)", names.providerName))
	if schema.hasRedisCache {
		g.addImport("strconv")
	}
	g.addLine("\treturn e")
	g.addLine("}")
	g.addLine("")
}

func (g *codeGenerator) generateUniqueIndexStubs(schema *entitySchema, names *entityNames) {
	for indexName, index := range schema.uniqueIndexes {
		g.body += fmt.Sprintf("func (p %s) GetByIndex%s(ctx fluxaorm.Context", names.providerNamePrivate, indexName)
		for _, columnName := range index.Columns {
			g.body += fmt.Sprintf(", %s any", g.lowerFirst(columnName))
		}
		g.addLine(fmt.Sprintf(") (entity *%s, found bool, err error) {", names.entityName))
		g.addLine("\treturn nil, false, nil")
		g.addLine("}")
		g.addLine("")
	}
}

func (g *codeGenerator) generateSearchWithCount(schema *entitySchema, names *entityNames) {
	g.addImport("strings")
	g.addLine(fmt.Sprintf("func (p %s) SearchWithCount(ctx fluxaorm.Context, where fluxaorm.Where, pager *fluxaorm.Pager) (entities []*%s, totalRows int, err error) {", names.providerNamePrivate, names.entityName))
	g.addLine("\tvar whereClause string")
	g.addLine("\tvar params []any")
	g.addLine("\tif where != nil {")
	g.addLine("\t\tparams = where.GetParameters()")
	g.addLine("\t\tif w := where.String(); w != \"\" {")
	g.addLine("\t\t\twhereClause = \" WHERE \" + w")
	g.addLine("\t\t}")
	g.addLine("\t}")
	if schema.hasFakeDelete {
		g.addLine("\tif where == nil || !where.IsWithFakeDeletes() {")
		g.addLine("\t\tif whereClause != \"\" {")
		g.addLine("\t\t\twhereClause += \" AND `FakeDelete` = 0\"")
		g.addLine("\t\t} else {")
		g.addLine("\t\t\twhereClause = \" WHERE `FakeDelete` = 0\"")
		g.addLine("\t\t}")
		g.addLine("\t}")
	}
	g.addLine("\tvar b strings.Builder")
	g.addLine(fmt.Sprintf("\tb.WriteString(\"SELECT COUNT(*) FROM `%s`\")", schema.tableName))
	g.addLine("\tb.WriteString(whereClause)")
	g.addLine(fmt.Sprintf("\t_, err = ctx.Engine().DB(%s.dbCode).QueryRow(ctx, fluxaorm.NewWhere(b.String(), params...), &totalRows)", names.providerName))
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, 0, err")
	g.addLine("\t}")
	g.addLine("\tif totalRows == 0 {")
	g.addLine("\t\treturn nil, 0, nil")
	g.addLine("\t}")
	g.addLine("\tb.Reset()")
	selectPrefix := "\"SELECT `ID`"
	for _, columnName := range schema.GetColumns()[1:] {
		selectPrefix += ",`" + columnName + "`"
	}
	selectPrefix += fmt.Sprintf(" FROM `%s`\"", schema.tableName)
	g.addLine(fmt.Sprintf("\tb.WriteString(%s)", selectPrefix))
	g.addLine("\tb.WriteString(whereClause)")
	g.addLine("\tif pager != nil {")
	g.addLine("\t\tb.WriteByte(' ')")
	g.addLine("\t\tb.WriteString(pager.String())")
	g.addLine("\t}")
	g.addLine(fmt.Sprintf("\trows, cl, err := ctx.Engine().DB(%s.dbCode).Query(ctx, b.String(), params...)", names.providerName))
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, 0, err")
	g.addLine("\t}")
	g.addLine("\tdefer cl()")
	g.addLine("\tfor rows.Next() {")
	g.addLine(fmt.Sprintf("\t\tsqlRow := &%s{}", names.sqlRowName))
	g.appendToLine(fmt.Sprintf("\t\tif err = rows.Scan(&sqlRow.F0"))
	for i := 1; i < len(schema.columnNames); i++ {
		g.appendToLine(fmt.Sprintf(", &sqlRow.F%d", i))
	}
	g.addLine("); err != nil {")
	g.addLine("\t\t\treturn nil, 0, err")
	g.addLine("\t\t}")
	g.addLine(fmt.Sprintf("\t\tentities = append(entities, &%s{ctx: ctx, id: sqlRow.F0, originDatabaseValues: sqlRow})", names.entityName))
	g.addLine("\t}")
	g.addLine("\treturn entities, totalRows, nil")
	g.addLine("}")
	g.addLine("")
}

func (g *codeGenerator) generateSearch(schema *entitySchema, names *entityNames) {
	g.addImport("strings")
	g.addLine(fmt.Sprintf("func (p %s) Search(ctx fluxaorm.Context, where fluxaorm.Where, pager *fluxaorm.Pager) (entities []*%s, err error) {", names.providerNamePrivate, names.entityName))
	g.addLine("\tvar b strings.Builder")
	selectPrefix := "\"SELECT `ID`"
	for _, columnName := range schema.GetColumns()[1:] {
		selectPrefix += ",`" + columnName + "`"
	}
	selectPrefix += fmt.Sprintf(" FROM `%s`\"", schema.tableName)
	g.addLine(fmt.Sprintf("\tb.WriteString(%s)", selectPrefix))
	g.addLine("\tvar params []any")
	if schema.hasFakeDelete {
		g.addLine("\tvar whereStr string")
		g.addLine("\tif where != nil {")
		g.addLine("\t\twhereStr = where.String()")
		g.addLine("\t\tparams = where.GetParameters()")
		g.addLine("\t}")
		g.addLine("\tif whereStr != \"\" {")
		g.addLine("\t\tb.WriteString(\" WHERE \")")
		g.addLine("\t\tb.WriteString(whereStr)")
		g.addLine("\t}")
		g.addLine("\tif where == nil || !where.IsWithFakeDeletes() {")
		g.addLine("\t\tif whereStr != \"\" {")
		g.addLine("\t\t\tb.WriteString(\" AND `FakeDelete` = 0\")")
		g.addLine("\t\t} else {")
		g.addLine("\t\t\tb.WriteString(\" WHERE `FakeDelete` = 0\")")
		g.addLine("\t\t}")
		g.addLine("\t}")
	} else {
		g.addLine("\tif where != nil {")
		g.addLine("\t\tif w := where.String(); w != \"\" {")
		g.addLine("\t\t\tb.WriteString(\" WHERE \")")
		g.addLine("\t\t\tb.WriteString(w)")
		g.addLine("\t\t}")
		g.addLine("\t\tparams = where.GetParameters()")
		g.addLine("\t}")
	}
	g.addLine("\tif pager != nil {")
	g.addLine("\t\tb.WriteByte(' ')")
	g.addLine("\t\tb.WriteString(pager.String())")
	g.addLine("\t}")
	g.addLine(fmt.Sprintf("\trows, cl, err := ctx.Engine().DB(%s.dbCode).Query(ctx, b.String(), params...)", names.providerName))
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, err")
	g.addLine("\t}")
	g.addLine("\tdefer cl()")
	g.addLine("\tfor rows.Next() {")
	g.addLine(fmt.Sprintf("\t\tsqlRow := &%s{}", names.sqlRowName))
	g.appendToLine(fmt.Sprintf("\t\tif err = rows.Scan(&sqlRow.F0"))
	for i := 1; i < len(schema.columnNames); i++ {
		g.appendToLine(fmt.Sprintf(", &sqlRow.F%d", i))
	}
	g.addLine("); err != nil {")
	g.addLine("\t\t\treturn nil, err")
	g.addLine("\t\t}")
	g.addLine(fmt.Sprintf("\t\tentities = append(entities, &%s{ctx: ctx, id: sqlRow.F0, originDatabaseValues: sqlRow})", names.entityName))
	g.addLine("\t}")
	g.addLine("\treturn entities, nil")
	g.addLine("}")
	g.addLine("")
}

func (g *codeGenerator) generateSearchIDsWithCount(schema *entitySchema, names *entityNames) {
	g.addImport("strings")
	g.addLine(fmt.Sprintf("func (p %s) SearchIDsWithCount(ctx fluxaorm.Context, where fluxaorm.Where, pager fluxaorm.Pager) (results []uint64, totalRows int, err error) {", names.providerNamePrivate))
	g.addLine("\tvar whereClause string")
	g.addLine("\tvar params []any")
	g.addLine("\tif where != nil {")
	g.addLine("\t\tparams = where.GetParameters()")
	g.addLine("\t\tif w := where.String(); w != \"\" {")
	g.addLine("\t\t\twhereClause = \" WHERE \" + w")
	g.addLine("\t\t}")
	g.addLine("\t}")
	if schema.hasFakeDelete {
		g.addLine("\tif where == nil || !where.IsWithFakeDeletes() {")
		g.addLine("\t\tif whereClause != \"\" {")
		g.addLine("\t\t\twhereClause += \" AND `FakeDelete` = 0\"")
		g.addLine("\t\t} else {")
		g.addLine("\t\t\twhereClause = \" WHERE `FakeDelete` = 0\"")
		g.addLine("\t\t}")
		g.addLine("\t}")
	}
	g.addLine("\tvar b strings.Builder")
	g.addLine(fmt.Sprintf("\tb.WriteString(\"SELECT COUNT(*) FROM `%s`\")", schema.tableName))
	g.addLine("\tb.WriteString(whereClause)")
	g.addLine(fmt.Sprintf("\t_, err = ctx.Engine().DB(%s.dbCode).QueryRow(ctx, fluxaorm.NewWhere(b.String(), params...), &totalRows)", names.providerName))
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, 0, err")
	g.addLine("\t}")
	g.addLine("\tif totalRows == 0 {")
	g.addLine("\t\treturn nil, 0, nil")
	g.addLine("\t}")
	g.addLine("\tb.Reset()")
	g.addLine(fmt.Sprintf("\tb.WriteString(\"SELECT `ID` FROM `%s`\")", schema.tableName))
	g.addLine("\tb.WriteString(whereClause)")
	g.addLine("\tb.WriteByte(' ')")
	g.addLine("\tb.WriteString(pager.String())")
	g.addLine(fmt.Sprintf("\trows, cl, err := ctx.Engine().DB(%s.dbCode).Query(ctx, b.String(), params...)", names.providerName))
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, 0, err")
	g.addLine("\t}")
	g.addLine("\tdefer cl()")
	g.addLine("\tfor rows.Next() {")
	g.addLine("\t\tvar id uint64")
	g.addLine("\t\tif err = rows.Scan(&id); err != nil {")
	g.addLine("\t\t\treturn nil, 0, err")
	g.addLine("\t\t}")
	g.addLine("\t\tresults = append(results, id)")
	g.addLine("\t}")
	g.addLine("\treturn results, totalRows, nil")
	g.addLine("}")
	g.addLine("")
}

func (g *codeGenerator) generateSearchIDs(schema *entitySchema, names *entityNames) {
	g.addImport("strings")
	g.addLine(fmt.Sprintf("func (p %s) SearchIDs(ctx fluxaorm.Context, where fluxaorm.Where, pager *fluxaorm.Pager) (results []uint64, err error) {", names.providerNamePrivate))
	g.addLine("\tvar b strings.Builder")
	g.addLine(fmt.Sprintf("\tb.WriteString(\"SELECT `ID` FROM `%s`\")", schema.tableName))
	g.addLine("\tvar params []any")
	if schema.hasFakeDelete {
		g.addLine("\tvar whereStr string")
		g.addLine("\tif where != nil {")
		g.addLine("\t\twhereStr = where.String()")
		g.addLine("\t\tparams = where.GetParameters()")
		g.addLine("\t}")
		g.addLine("\tif whereStr != \"\" {")
		g.addLine("\t\tb.WriteString(\" WHERE \")")
		g.addLine("\t\tb.WriteString(whereStr)")
		g.addLine("\t}")
		g.addLine("\tif where == nil || !where.IsWithFakeDeletes() {")
		g.addLine("\t\tif whereStr != \"\" {")
		g.addLine("\t\t\tb.WriteString(\" AND `FakeDelete` = 0\")")
		g.addLine("\t\t} else {")
		g.addLine("\t\t\tb.WriteString(\" WHERE `FakeDelete` = 0\")")
		g.addLine("\t\t}")
		g.addLine("\t}")
	} else {
		g.addLine("\tif where != nil {")
		g.addLine("\t\tif w := where.String(); w != \"\" {")
		g.addLine("\t\t\tb.WriteString(\" WHERE \")")
		g.addLine("\t\t\tb.WriteString(w)")
		g.addLine("\t\t}")
		g.addLine("\t\tparams = where.GetParameters()")
		g.addLine("\t}")
	}
	g.addLine("\tif pager != nil {")
	g.addLine("\t\tb.WriteByte(' ')")
	g.addLine("\t\tb.WriteString(pager.String())")
	g.addLine("\t}")
	g.addLine(fmt.Sprintf("\trows, cl, err := ctx.Engine().DB(%s.dbCode).Query(ctx, b.String(), params...)", names.providerName))
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, err")
	g.addLine("\t}")
	g.addLine("\tdefer cl()")
	g.addLine("\tfor rows.Next() {")
	g.addLine("\t\tvar id uint64")
	g.addLine("\t\tif err = rows.Scan(&id); err != nil {")
	g.addLine("\t\t\treturn nil, err")
	g.addLine("\t\t}")
	g.addLine("\t\tresults = append(results, id)")
	g.addLine("\t}")
	g.addLine("\treturn results, nil")
	g.addLine("}")
	g.addLine("")
}

func (g *codeGenerator) generateSearchOne(schema *entitySchema, names *entityNames) {
	g.addImport("strings")
	g.addLine(fmt.Sprintf("func (p %s) SearchOne(ctx fluxaorm.Context, where fluxaorm.Where) (entity *%s, found bool, err error) {", names.providerNamePrivate, names.entityName))
	g.addLine("\tvar b strings.Builder")
	selectPrefix := "\"SELECT `ID`"
	for _, columnName := range schema.GetColumns()[1:] {
		selectPrefix += ",`" + columnName + "`"
	}
	selectPrefix += fmt.Sprintf(" FROM `%s`\"", schema.tableName)
	g.addLine(fmt.Sprintf("\tb.WriteString(%s)", selectPrefix))
	g.addLine("\tvar params []any")
	if schema.hasFakeDelete {
		g.addLine("\tvar whereStr string")
		g.addLine("\tif where != nil {")
		g.addLine("\t\twhereStr = where.String()")
		g.addLine("\t\tparams = where.GetParameters()")
		g.addLine("\t}")
		g.addLine("\tif whereStr != \"\" {")
		g.addLine("\t\tb.WriteString(\" WHERE \")")
		g.addLine("\t\tb.WriteString(whereStr)")
		g.addLine("\t}")
		g.addLine("\tif where == nil || !where.IsWithFakeDeletes() {")
		g.addLine("\t\tif whereStr != \"\" {")
		g.addLine("\t\t\tb.WriteString(\" AND `FakeDelete` = 0\")")
		g.addLine("\t\t} else {")
		g.addLine("\t\t\tb.WriteString(\" WHERE `FakeDelete` = 0\")")
		g.addLine("\t\t}")
		g.addLine("\t}")
	} else {
		g.addLine("\tif where != nil {")
		g.addLine("\t\tif w := where.String(); w != \"\" {")
		g.addLine("\t\t\tb.WriteString(\" WHERE \")")
		g.addLine("\t\t\tb.WriteString(w)")
		g.addLine("\t\t}")
		g.addLine("\t\tparams = where.GetParameters()")
		g.addLine("\t}")
	}
	g.addLine("\tb.WriteString(\" LIMIT 1\")")
	g.addLine(fmt.Sprintf("\tsqlRow := &%s{}", names.sqlRowName))
	g.appendToLine(fmt.Sprintf("\tfound, err = ctx.Engine().DB(%s.dbCode).QueryRow(ctx, fluxaorm.NewWhere(b.String(), params...), &sqlRow.F0", names.providerName))
	for i := 1; i < len(schema.columnNames); i++ {
		g.appendToLine(fmt.Sprintf(", &sqlRow.F%d", i))
	}
	g.addLine(")")
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, false, err")
	g.addLine("\t}")
	g.addLine("\tif !found {")
	g.addLine("\t\treturn nil, false, nil")
	g.addLine("\t}")
	g.addLine(fmt.Sprintf("\treturn &%s{ctx: ctx, id: sqlRow.F0, originDatabaseValues: sqlRow}, true, nil", names.entityName))
	g.addLine("}")
	g.addLine("")
}
