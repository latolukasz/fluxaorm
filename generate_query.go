package fluxaorm

import "fmt"

func (g *codeGenerator) generateGetByID(schema *entitySchema, names *entityNames) {
	g.addLine(fmt.Sprintf("func (p %s) GetByID(ctx fluxaorm.Context, id uint64) (entity *%s, found bool, err error) {", names.providerNamePrivate, names.entityName))
	g.addLine("\tif cached := ctx.GetFromContextCache(p.cacheIndex, id); cached != nil {")
	g.addLine(fmt.Sprintf("\t\treturn cached.(*%s), true, nil", names.entityName))
	g.addLine("\t}")
	if schema.hasRedisCache {
		g.addLine("\tredisKey := p.redisCachePrefix + strconv.FormatUint(id, 10)")
		g.addLine("\tredisValues, err := ctx.Engine().Redis(p.redisCode).LRange(ctx, redisKey, 0, -1)")
		g.addLine("\tif err != nil {")
		g.addLine("\t\treturn nil, false, err")
		g.addLine("\t}")
		g.addLine("\tif len(redisValues) == 1 && redisValues[0] == \"\" {")
		g.addLine("\t\treturn nil, false, nil")
		g.addLine("\t}")
		g.addLine("\tif len(redisValues) > 1 && redisValues[0] == p.redisCacheStamp {")
		g.addLine(fmt.Sprintf("\t\te := &%s{ctx: ctx, id: id, originRedisValues: redisValues[1:]}", names.entityName))
		g.addLine("\t\tctx.SetInContextCache(p.cacheIndex, id, e)")
		g.addLine("\t\treturn e, true, nil")
		g.addLine("\t}")
	}
	g.appendToLine("\tquery := \"SELECT `ID`")
	for _, columnName := range schema.GetColumns()[1:] {
		g.appendToLine(",`" + columnName + "`")
	}
	g.addLine(fmt.Sprintf(" FROM `%s` WHERE `ID` = ? LIMIT 1\"", schema.tableName))
	g.addLine(fmt.Sprintf("\tsqlRow := &%s{}", names.sqlRowName))
	g.appendToLine(fmt.Sprintf("\tfound, err = ctx.Engine().DB(%s.dbCode).QueryRow(ctx, fluxaorm.NewWhere(query, id), &sqlRow.F0", names.providerName))
	for i := 1; i < len(schema.columnNames); i++ {
		g.appendToLine(fmt.Sprintf(", &sqlRow.F%d", i))
	}
	g.addLine(")")
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, false, err")
	g.addLine("\t}")
	g.addLine("\tif !found {")
	if schema.hasRedisCache {
		g.addLine("\t\tredisPipeline := ctx.RedisPipeLine(p.redisCode)")
		g.addLine("\t\tredisPipeline.Del(redisKey)")
		g.addLine("\t\tredisPipeline.RPush(redisKey, \"\")")
		g.addLine("\t\t_, err = redisPipeline.Exec(ctx)")
		g.addLine("\t\tif err != nil {")
		g.addLine("\t\t\treturn nil, false, err")
		g.addLine("\t\t}")
	}
	g.addLine("\t\treturn nil, false, nil")
	g.addLine("\t}")
	if schema.hasRedisCache {
		g.addLine("\t_, err = ctx.Engine().Redis(p.redisCode).RPush(ctx, redisKey, sqlRow.redisValues()...)")
		g.addLine("\tif err != nil {")
		g.addLine("\t\treturn nil, false, err")
		g.addLine("\t}")
	}
	g.addLine(fmt.Sprintf("\te := &%s{ctx: ctx, id: id, originDatabaseValues: sqlRow}", names.entityName))
	g.addLine("\tctx.SetInContextCache(p.cacheIndex, id, e)")
	g.addLine("\treturn e, true, nil")
	g.addLine("}")
	g.addLine("")
}

func (g *codeGenerator) generateGetByIDs(schema *entitySchema, names *entityNames) {
	g.addImport("strings")
	g.addImport("strconv")
	g.addLine(fmt.Sprintf("func (p %s) GetByIDs(ctx fluxaorm.Context, id ...uint64) ([]*%s, error) {", names.providerNamePrivate, names.entityName))
	g.addLine("\tif len(id) == 0 {")
	g.addLine("\t\treturn nil, nil")
	g.addLine("\t}")
	g.addLine(fmt.Sprintf("\tresultMap := make(map[uint64]*%s, len(id))", names.entityName))
	g.addLine("\tuniqueIDs := make([]uint64, 0, len(id))")
	g.addLine("\tfor _, v := range id {")
	g.addLine("\t\tif _, exists := resultMap[v]; !exists {")
	g.addLine("\t\t\tresultMap[v] = nil")
	g.addLine("\t\t\tuniqueIDs = append(uniqueIDs, v)")
	g.addLine("\t\t}")
	g.addLine("\t}")
	g.addLine("\tidsToFetch := make([]uint64, 0, len(uniqueIDs))")
	g.addLine("\tfor _, v := range uniqueIDs {")
	g.addLine("\t\tif cached := ctx.GetFromContextCache(p.cacheIndex, v); cached != nil {")
	g.addLine(fmt.Sprintf("\t\t\tresultMap[v] = cached.(*%s)", names.entityName))
	g.addLine("\t\t} else {")
	g.addLine("\t\t\tidsToFetch = append(idsToFetch, v)")
	g.addLine("\t\t}")
	g.addLine("\t}")
	selectPrefix := "SELECT `ID`"
	for _, columnName := range schema.GetColumns()[1:] {
		selectPrefix += ",`" + columnName + "`"
	}
	g.addLine("\tif len(idsToFetch) > 0 {")
	if schema.hasRedisCache {
		g.addLine("\t\tredisPipeline := ctx.RedisPipeLine(p.redisCode)")
		g.addLine("\t\tredisResults := make([]*fluxaorm.PipeLineSlice, len(idsToFetch))")
		g.addLine("\t\tfor i, v := range idsToFetch {")
		g.addLine("\t\t\tredisResults[i] = redisPipeline.LRange(p.redisCachePrefix+strconv.FormatUint(v, 10), 0, -1)")
		g.addLine("\t\t}")
		g.addLine("\t\t_, err := redisPipeline.Exec(ctx)")
		g.addLine("\t\tif err != nil {")
		g.addLine("\t\t\treturn nil, err")
		g.addLine("\t\t}")
		g.addLine("\t\tmissingIDs := make([]uint64, 0, len(idsToFetch))")
		g.addLine("\t\tfor i, v := range idsToFetch {")
		g.addLine("\t\t\tvalues, err := redisResults[i].Result()")
		g.addLine("\t\t\tif err != nil {")
		g.addLine("\t\t\t\treturn nil, err")
		g.addLine("\t\t\t}")
		g.addLine("\t\t\tif len(values) == 1 && values[0] == \"\" {")
		g.addLine("\t\t\t\tcontinue")
		g.addLine("\t\t\t}")
		g.addLine("\t\t\tif len(values) > 1 && values[0] == p.redisCacheStamp {")
		g.addLine(fmt.Sprintf("\t\t\t\te := &%s{ctx: ctx, id: v, originRedisValues: values[1:]}", names.entityName))
		g.addLine("\t\t\t\tresultMap[v] = e")
		g.addLine("\t\t\t\tctx.SetInContextCache(p.cacheIndex, v, e)")
		g.addLine("\t\t\t\tcontinue")
		g.addLine("\t\t\t}")
		g.addLine("\t\t\tmissingIDs = append(missingIDs, v)")
		g.addLine("\t\t}")
		g.addLine("\t\tif len(missingIDs) > 0 {")
		selectPrefixFull := selectPrefix + fmt.Sprintf(" FROM `%s` WHERE `ID` IN (", schema.tableName)
		g.addLine("\t\t\tvar b strings.Builder")
		g.addLine(fmt.Sprintf("\t\t\tb.WriteString(%q)", selectPrefixFull))
		g.addLine("\t\t\tb.WriteString(strconv.FormatUint(missingIDs[0], 10))")
		g.addLine("\t\t\tfor _, v := range missingIDs[1:] {")
		g.addLine("\t\t\t\tb.WriteByte(',')")
		g.addLine("\t\t\t\tb.WriteString(strconv.FormatUint(v, 10))")
		g.addLine("\t\t\t}")
		g.addLine("\t\t\tb.WriteByte(')')")
		g.addLine(fmt.Sprintf("\t\t\trows, cl, err := ctx.Engine().DB(%s.dbCode).Query(ctx, b.String())", names.providerName))
		g.addLine("\t\t\tif err != nil {")
		g.addLine("\t\t\t\treturn nil, err")
		g.addLine("\t\t\t}")
		g.addLine("\t\t\tdefer cl()")
		g.addLine("\t\t\tfoundInDB := make(map[uint64]bool, len(missingIDs))")
		g.addLine("\t\t\tcachePipeline := ctx.RedisPipeLine(p.redisCode)")
		g.addLine("\t\t\tfor rows.Next() {")
		g.addLine(fmt.Sprintf("\t\t\t\tsqlRow := &%s{}", names.sqlRowName))
		g.appendToLine("\t\t\t\terr = rows.Scan(&sqlRow.F0")
		for i := 1; i < len(schema.columnNames); i++ {
			g.appendToLine(fmt.Sprintf(", &sqlRow.F%d", i))
		}
		g.addLine(")")
		g.addLine("\t\t\t\tif err != nil {")
		g.addLine("\t\t\t\t\treturn nil, err")
		g.addLine("\t\t\t\t}")
		g.addLine(fmt.Sprintf("\t\t\t\te := &%s{ctx: ctx, id: sqlRow.F0, originDatabaseValues: sqlRow}", names.entityName))
		g.addLine("\t\t\t\tresultMap[sqlRow.F0] = e")
		g.addLine("\t\t\t\tfoundInDB[sqlRow.F0] = true")
		g.addLine("\t\t\t\tcachePipeline.RPush(p.redisCachePrefix+strconv.FormatUint(sqlRow.F0, 10), sqlRow.redisValues()...)")
		g.addLine("\t\t\t\tctx.SetInContextCache(p.cacheIndex, sqlRow.F0, e)")
		g.addLine("\t\t\t}")
		g.addLine("\t\t\tfor _, v := range missingIDs {")
		g.addLine("\t\t\t\tif !foundInDB[v] {")
		g.addLine("\t\t\t\t\tredisKey := p.redisCachePrefix + strconv.FormatUint(v, 10)")
		g.addLine("\t\t\t\t\tcachePipeline.Del(redisKey)")
		g.addLine("\t\t\t\t\tcachePipeline.RPush(redisKey, \"\")")
		g.addLine("\t\t\t\t}")
		g.addLine("\t\t\t}")
		g.addLine("\t\t\t_, err = cachePipeline.Exec(ctx)")
		g.addLine("\t\t\tif err != nil {")
		g.addLine("\t\t\t\treturn nil, err")
		g.addLine("\t\t\t}")
		g.addLine("\t\t}")
	} else {
		selectPrefix += fmt.Sprintf(" FROM `%s` WHERE `ID` IN (", schema.tableName)
		g.addLine("\t\tvar b strings.Builder")
		g.addLine(fmt.Sprintf("\t\tb.WriteString(%q)", selectPrefix))
		g.addLine("\t\tb.WriteString(strconv.FormatUint(idsToFetch[0], 10))")
		g.addLine("\t\tfor _, v := range idsToFetch[1:] {")
		g.addLine("\t\t\tb.WriteByte(',')")
		g.addLine("\t\t\tb.WriteString(strconv.FormatUint(v, 10))")
		g.addLine("\t\t}")
		g.addLine("\t\tb.WriteByte(')')")
		g.addLine(fmt.Sprintf("\t\trows, cl, err := ctx.Engine().DB(%s.dbCode).Query(ctx, b.String())", names.providerName))
		g.addLine("\t\tif err != nil {")
		g.addLine("\t\t\treturn nil, err")
		g.addLine("\t\t}")
		g.addLine("\t\tdefer cl()")
		g.addLine("\t\tfor rows.Next() {")
		g.addLine(fmt.Sprintf("\t\t\tsqlRow := &%s{}", names.sqlRowName))
		g.appendToLine("\t\t\terr = rows.Scan(&sqlRow.F0")
		for i := 1; i < len(schema.columnNames); i++ {
			g.appendToLine(fmt.Sprintf(", &sqlRow.F%d", i))
		}
		g.addLine(")")
		g.addLine("\t\t\tif err != nil {")
		g.addLine("\t\t\t\treturn nil, err")
		g.addLine("\t\t\t}")
		g.addLine(fmt.Sprintf("\t\t\te := &%s{ctx: ctx, id: sqlRow.F0, originDatabaseValues: sqlRow}", names.entityName))
		g.addLine("\t\t\tresultMap[sqlRow.F0] = e")
		g.addLine("\t\t\tctx.SetInContextCache(p.cacheIndex, sqlRow.F0, e)")
		g.addLine("\t\t}")
	}
	g.addLine("\t}")
	g.addLine(fmt.Sprintf("\tresult := make([]*%s, 0, len(uniqueIDs))", names.entityName))
	g.addLine("\tfor _, v := range uniqueIDs {")
	g.addLine("\t\tif e := resultMap[v]; e != nil {")
	g.addLine("\t\t\tresult = append(result, e)")
	g.addLine("\t\t}")
	g.addLine("\t}")
	g.addLine("\treturn result, nil")
	g.addLine("}")
	g.addLine("")
}

func (g *codeGenerator) generateNewMethods(schema *entitySchema, names *entityNames) {
	g.addLine(fmt.Sprintf("func (p %s) New(ctx fluxaorm.Context) *%s  {", names.providerNamePrivate, names.entityName))
	g.addLine(fmt.Sprintf("\treturn p.NewWithID(ctx, p.uuid(ctx))"))
	g.addLine("}")
	g.addLine("")
	g.addLine(fmt.Sprintf("func (p %s) NewWithID(ctx fluxaorm.Context, id uint64) *%s  {", names.providerNamePrivate, names.entityName))
	g.addLine(fmt.Sprintf("\te := &%s{ctx: ctx, new: true, id: id, originDatabaseValues: &%s{F0: id}}", names.entityName, names.sqlRowName))
	g.addLine(fmt.Sprintf("\te.ctx.Track(e, %s.cacheIndex)", names.providerName))
	if schema.hasRedisCache {
		g.addImport("strconv")
	}
	g.addLine("\treturn e")
	g.addLine("}")
	g.addLine("")
}

func (g *codeGenerator) generateUniqueIndexStubs(schema *entitySchema, names *entityNames) {
	for indexName, index := range schema.uniqueIndexes {
		g.body += fmt.Sprintf("func (p %s) GetByIndex%s(ctx fluxaorm.Context", names.providerNamePrivate, indexName)
		for _, columnName := range index.Columns {
			g.body += fmt.Sprintf(", %s any", g.lowerFirst(columnName))
		}
		g.addLine(fmt.Sprintf(") (entity *%s, found bool, err error) {", names.entityName))
		g.addLine("\treturn nil, false, nil")
		g.addLine("}")
		g.addLine("")
	}
}

func (g *codeGenerator) generateSearchWithCount(schema *entitySchema, names *entityNames) {
	g.addImport("strings")
	g.addLine(fmt.Sprintf("func (p %s) SearchWithCount(ctx fluxaorm.Context, where fluxaorm.Where, pager *fluxaorm.Pager) (entities []*%s, totalRows int, err error) {", names.providerNamePrivate, names.entityName))
	g.addLine("\tvar whereClause string")
	g.addLine("\tvar params []any")
	g.addLine("\tif where != nil {")
	g.addLine("\t\tparams = where.GetParameters()")
	g.addLine("\t\tif w := where.String(); w != \"\" {")
	g.addLine("\t\t\twhereClause = \" WHERE \" + w")
	g.addLine("\t\t}")
	g.addLine("\t}")
	if schema.hasFakeDelete {
		g.addLine("\tif where == nil || !where.IsWithFakeDeletes() {")
		g.addLine("\t\tif whereClause != \"\" {")
		g.addLine("\t\t\twhereClause += \" AND `FakeDelete` = 0\"")
		g.addLine("\t\t} else {")
		g.addLine("\t\t\twhereClause = \" WHERE `FakeDelete` = 0\"")
		g.addLine("\t\t}")
		g.addLine("\t}")
	}
	g.addLine("\tvar b strings.Builder")
	g.addLine(fmt.Sprintf("\tb.WriteString(\"SELECT COUNT(*) FROM `%s`\")", schema.tableName))
	g.addLine("\tb.WriteString(whereClause)")
	g.addLine(fmt.Sprintf("\t_, err = ctx.Engine().DB(%s.dbCode).QueryRow(ctx, fluxaorm.NewWhere(b.String(), params...), &totalRows)", names.providerName))
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, 0, err")
	g.addLine("\t}")
	g.addLine("\tif totalRows == 0 {")
	g.addLine("\t\treturn nil, 0, nil")
	g.addLine("\t}")
	g.addLine("\tb.Reset()")
	selectPrefix := "\"SELECT `ID`"
	for _, columnName := range schema.GetColumns()[1:] {
		selectPrefix += ",`" + columnName + "`"
	}
	selectPrefix += fmt.Sprintf(" FROM `%s`\"", schema.tableName)
	g.addLine(fmt.Sprintf("\tb.WriteString(%s)", selectPrefix))
	g.addLine("\tb.WriteString(whereClause)")
	g.addLine("\tif pager != nil {")
	g.addLine("\t\tb.WriteByte(' ')")
	g.addLine("\t\tb.WriteString(pager.String())")
	g.addLine("\t}")
	g.addLine(fmt.Sprintf("\trows, cl, err := ctx.Engine().DB(%s.dbCode).Query(ctx, b.String(), params...)", names.providerName))
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, 0, err")
	g.addLine("\t}")
	g.addLine("\tdefer cl()")
	g.addLine("\tfor rows.Next() {")
	g.addLine(fmt.Sprintf("\t\tsqlRow := &%s{}", names.sqlRowName))
	g.appendToLine(fmt.Sprintf("\t\tif err = rows.Scan(&sqlRow.F0"))
	for i := 1; i < len(schema.columnNames); i++ {
		g.appendToLine(fmt.Sprintf(", &sqlRow.F%d", i))
	}
	g.addLine("); err != nil {")
	g.addLine("\t\t\treturn nil, 0, err")
	g.addLine("\t\t}")
	g.addLine(fmt.Sprintf("\t\tentities = append(entities, &%s{ctx: ctx, id: sqlRow.F0, originDatabaseValues: sqlRow})", names.entityName))
	g.addLine("\t}")
	g.addLine("\treturn entities, totalRows, nil")
	g.addLine("}")
	g.addLine("")
}

func (g *codeGenerator) generateSearch(schema *entitySchema, names *entityNames) {
	g.addImport("strings")
	g.addLine(fmt.Sprintf("func (p %s) Search(ctx fluxaorm.Context, where fluxaorm.Where, pager *fluxaorm.Pager) (entities []*%s, err error) {", names.providerNamePrivate, names.entityName))
	g.addLine("\tvar b strings.Builder")
	selectPrefix := "\"SELECT `ID`"
	for _, columnName := range schema.GetColumns()[1:] {
		selectPrefix += ",`" + columnName + "`"
	}
	selectPrefix += fmt.Sprintf(" FROM `%s`\"", schema.tableName)
	g.addLine(fmt.Sprintf("\tb.WriteString(%s)", selectPrefix))
	g.addLine("\tvar params []any")
	if schema.hasFakeDelete {
		g.addLine("\tvar whereStr string")
		g.addLine("\tif where != nil {")
		g.addLine("\t\twhereStr = where.String()")
		g.addLine("\t\tparams = where.GetParameters()")
		g.addLine("\t}")
		g.addLine("\tif whereStr != \"\" {")
		g.addLine("\t\tb.WriteString(\" WHERE \")")
		g.addLine("\t\tb.WriteString(whereStr)")
		g.addLine("\t}")
		g.addLine("\tif where == nil || !where.IsWithFakeDeletes() {")
		g.addLine("\t\tif whereStr != \"\" {")
		g.addLine("\t\t\tb.WriteString(\" AND `FakeDelete` = 0\")")
		g.addLine("\t\t} else {")
		g.addLine("\t\t\tb.WriteString(\" WHERE `FakeDelete` = 0\")")
		g.addLine("\t\t}")
		g.addLine("\t}")
	} else {
		g.addLine("\tif where != nil {")
		g.addLine("\t\tif w := where.String(); w != \"\" {")
		g.addLine("\t\t\tb.WriteString(\" WHERE \")")
		g.addLine("\t\t\tb.WriteString(w)")
		g.addLine("\t\t}")
		g.addLine("\t\tparams = where.GetParameters()")
		g.addLine("\t}")
	}
	g.addLine("\tif pager != nil {")
	g.addLine("\t\tb.WriteByte(' ')")
	g.addLine("\t\tb.WriteString(pager.String())")
	g.addLine("\t}")
	g.addLine(fmt.Sprintf("\trows, cl, err := ctx.Engine().DB(%s.dbCode).Query(ctx, b.String(), params...)", names.providerName))
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, err")
	g.addLine("\t}")
	g.addLine("\tdefer cl()")
	g.addLine("\tfor rows.Next() {")
	g.addLine(fmt.Sprintf("\t\tsqlRow := &%s{}", names.sqlRowName))
	g.appendToLine(fmt.Sprintf("\t\tif err = rows.Scan(&sqlRow.F0"))
	for i := 1; i < len(schema.columnNames); i++ {
		g.appendToLine(fmt.Sprintf(", &sqlRow.F%d", i))
	}
	g.addLine("); err != nil {")
	g.addLine("\t\t\treturn nil, err")
	g.addLine("\t\t}")
	g.addLine(fmt.Sprintf("\t\tentities = append(entities, &%s{ctx: ctx, id: sqlRow.F0, originDatabaseValues: sqlRow})", names.entityName))
	g.addLine("\t}")
	g.addLine("\treturn entities, nil")
	g.addLine("}")
	g.addLine("")
}

func (g *codeGenerator) generateSearchIDsWithCount(schema *entitySchema, names *entityNames) {
	g.addImport("strings")
	g.addLine(fmt.Sprintf("func (p %s) SearchIDsWithCount(ctx fluxaorm.Context, where fluxaorm.Where, pager fluxaorm.Pager) (results []uint64, totalRows int, err error) {", names.providerNamePrivate))
	g.addLine("\tvar whereClause string")
	g.addLine("\tvar params []any")
	g.addLine("\tif where != nil {")
	g.addLine("\t\tparams = where.GetParameters()")
	g.addLine("\t\tif w := where.String(); w != \"\" {")
	g.addLine("\t\t\twhereClause = \" WHERE \" + w")
	g.addLine("\t\t}")
	g.addLine("\t}")
	if schema.hasFakeDelete {
		g.addLine("\tif where == nil || !where.IsWithFakeDeletes() {")
		g.addLine("\t\tif whereClause != \"\" {")
		g.addLine("\t\t\twhereClause += \" AND `FakeDelete` = 0\"")
		g.addLine("\t\t} else {")
		g.addLine("\t\t\twhereClause = \" WHERE `FakeDelete` = 0\"")
		g.addLine("\t\t}")
		g.addLine("\t}")
	}
	g.addLine("\tvar b strings.Builder")
	g.addLine(fmt.Sprintf("\tb.WriteString(\"SELECT COUNT(*) FROM `%s`\")", schema.tableName))
	g.addLine("\tb.WriteString(whereClause)")
	g.addLine(fmt.Sprintf("\t_, err = ctx.Engine().DB(%s.dbCode).QueryRow(ctx, fluxaorm.NewWhere(b.String(), params...), &totalRows)", names.providerName))
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, 0, err")
	g.addLine("\t}")
	g.addLine("\tif totalRows == 0 {")
	g.addLine("\t\treturn nil, 0, nil")
	g.addLine("\t}")
	g.addLine("\tb.Reset()")
	g.addLine(fmt.Sprintf("\tb.WriteString(\"SELECT `ID` FROM `%s`\")", schema.tableName))
	g.addLine("\tb.WriteString(whereClause)")
	g.addLine("\tb.WriteByte(' ')")
	g.addLine("\tb.WriteString(pager.String())")
	g.addLine(fmt.Sprintf("\trows, cl, err := ctx.Engine().DB(%s.dbCode).Query(ctx, b.String(), params...)", names.providerName))
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, 0, err")
	g.addLine("\t}")
	g.addLine("\tdefer cl()")
	g.addLine("\tfor rows.Next() {")
	g.addLine("\t\tvar id uint64")
	g.addLine("\t\tif err = rows.Scan(&id); err != nil {")
	g.addLine("\t\t\treturn nil, 0, err")
	g.addLine("\t\t}")
	g.addLine("\t\tresults = append(results, id)")
	g.addLine("\t}")
	g.addLine("\treturn results, totalRows, nil")
	g.addLine("}")
	g.addLine("")
}

func (g *codeGenerator) generateSearchIDs(schema *entitySchema, names *entityNames) {
	g.addImport("strings")
	g.addLine(fmt.Sprintf("func (p %s) SearchIDs(ctx fluxaorm.Context, where fluxaorm.Where, pager *fluxaorm.Pager) (results []uint64, err error) {", names.providerNamePrivate))
	g.addLine("\tvar b strings.Builder")
	g.addLine(fmt.Sprintf("\tb.WriteString(\"SELECT `ID` FROM `%s`\")", schema.tableName))
	g.addLine("\tvar params []any")
	if schema.hasFakeDelete {
		g.addLine("\tvar whereStr string")
		g.addLine("\tif where != nil {")
		g.addLine("\t\twhereStr = where.String()")
		g.addLine("\t\tparams = where.GetParameters()")
		g.addLine("\t}")
		g.addLine("\tif whereStr != \"\" {")
		g.addLine("\t\tb.WriteString(\" WHERE \")")
		g.addLine("\t\tb.WriteString(whereStr)")
		g.addLine("\t}")
		g.addLine("\tif where == nil || !where.IsWithFakeDeletes() {")
		g.addLine("\t\tif whereStr != \"\" {")
		g.addLine("\t\t\tb.WriteString(\" AND `FakeDelete` = 0\")")
		g.addLine("\t\t} else {")
		g.addLine("\t\t\tb.WriteString(\" WHERE `FakeDelete` = 0\")")
		g.addLine("\t\t}")
		g.addLine("\t}")
	} else {
		g.addLine("\tif where != nil {")
		g.addLine("\t\tif w := where.String(); w != \"\" {")
		g.addLine("\t\t\tb.WriteString(\" WHERE \")")
		g.addLine("\t\t\tb.WriteString(w)")
		g.addLine("\t\t}")
		g.addLine("\t\tparams = where.GetParameters()")
		g.addLine("\t}")
	}
	g.addLine("\tif pager != nil {")
	g.addLine("\t\tb.WriteByte(' ')")
	g.addLine("\t\tb.WriteString(pager.String())")
	g.addLine("\t}")
	g.addLine(fmt.Sprintf("\trows, cl, err := ctx.Engine().DB(%s.dbCode).Query(ctx, b.String(), params...)", names.providerName))
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, err")
	g.addLine("\t}")
	g.addLine("\tdefer cl()")
	g.addLine("\tfor rows.Next() {")
	g.addLine("\t\tvar id uint64")
	g.addLine("\t\tif err = rows.Scan(&id); err != nil {")
	g.addLine("\t\t\treturn nil, err")
	g.addLine("\t\t}")
	g.addLine("\t\tresults = append(results, id)")
	g.addLine("\t}")
	g.addLine("\treturn results, nil")
	g.addLine("}")
	g.addLine("")
}

func (g *codeGenerator) generateSearchInRedis(schema *entitySchema, names *entityNames) {
	g.addImport("strings")
	g.addImport("strconv")
	g.addLine(fmt.Sprintf("func (p %s) SearchInRedis(ctx fluxaorm.Context, where *fluxaorm.RedisSearchWhere, pager *fluxaorm.Pager) ([]*%s, error) {", names.providerNamePrivate, names.entityName))
	g.addLine("\toffset, count := 0, 10000")
	g.addLine("\tif pager != nil {")
	g.addLine("\t\toffset = (pager.CurrentPage - 1) * pager.PageSize")
	g.addLine("\t\tcount = pager.PageSize")
	g.addLine("\t}")
	g.addLine("\tresult, err := ctx.Engine().Redis(p.redisSearchCode).FTSearch(ctx, p.redisSearchIndex, where.String(), where.GetSearchOptions(offset, count))")
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, err")
	g.addLine("\t}")
	g.addLine("\tif len(result.Docs) == 0 {")
	g.addLine("\t\treturn nil, nil")
	g.addLine("\t}")
	g.addLine("\tids := make([]uint64, 0, len(result.Docs))")
	g.addLine("\tfor _, doc := range result.Docs {")
	g.addLine("\t\tid, err := strconv.ParseUint(strings.TrimPrefix(doc.ID, p.redisSearchPrefix), 10, 64)")
	g.addLine("\t\tif err != nil {")
	g.addLine("\t\t\treturn nil, err")
	g.addLine("\t\t}")
	g.addLine("\t\tids = append(ids, id)")
	g.addLine("\t}")
	g.addLine("\treturn p.GetByIDs(ctx, ids...)")
	g.addLine("}")
	g.addLine("")
}

func (g *codeGenerator) generateSearchOneInRedis(schema *entitySchema, names *entityNames) {
	g.addImport("strings")
	g.addImport("strconv")
	g.addLine(fmt.Sprintf("func (p %s) SearchOneInRedis(ctx fluxaorm.Context, where *fluxaorm.RedisSearchWhere) (*%s, bool, error) {", names.providerNamePrivate, names.entityName))
	g.addLine("\tresult, err := ctx.Engine().Redis(p.redisSearchCode).FTSearch(ctx, p.redisSearchIndex, where.String(), where.GetSearchOptions(0, 1))")
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, false, err")
	g.addLine("\t}")
	g.addLine("\tif len(result.Docs) == 0 {")
	g.addLine("\t\treturn nil, false, nil")
	g.addLine("\t}")
	g.addLine("\tid, err := strconv.ParseUint(strings.TrimPrefix(result.Docs[0].ID, p.redisSearchPrefix), 10, 64)")
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, false, err")
	g.addLine("\t}")
	g.addLine(fmt.Sprintf("\tentities, err := p.GetByIDs(ctx, id)"))
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, false, err")
	g.addLine("\t}")
	g.addLine("\tif len(entities) == 0 {")
	g.addLine("\t\treturn nil, false, nil")
	g.addLine("\t}")
	g.addLine("\treturn entities[0], true, nil")
	g.addLine("}")
	g.addLine("")
}

func (g *codeGenerator) generateSearchInRedisWithCount(schema *entitySchema, names *entityNames) {
	g.addImport("strings")
	g.addImport("strconv")
	g.addLine(fmt.Sprintf("func (p %s) SearchInRedisWithCount(ctx fluxaorm.Context, where *fluxaorm.RedisSearchWhere, pager *fluxaorm.Pager) ([]*%s, int, error) {", names.providerNamePrivate, names.entityName))
	g.addLine("\tcountResult, err := ctx.Engine().Redis(p.redisSearchCode).FTSearch(ctx, p.redisSearchIndex, where.String(), where.GetSearchOptions(0, 0))")
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, 0, err")
	g.addLine("\t}")
	g.addLine("\ttotal := countResult.Total")
	g.addLine("\tif total == 0 {")
	g.addLine("\t\treturn nil, 0, nil")
	g.addLine("\t}")
	g.addLine("\toffset, count := 0, 10000")
	g.addLine("\tif pager != nil {")
	g.addLine("\t\toffset = (pager.CurrentPage - 1) * pager.PageSize")
	g.addLine("\t\tcount = pager.PageSize")
	g.addLine("\t}")
	g.addLine("\tresult, err := ctx.Engine().Redis(p.redisSearchCode).FTSearch(ctx, p.redisSearchIndex, where.String(), where.GetSearchOptions(offset, count))")
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, total, err")
	g.addLine("\t}")
	g.addLine("\tif len(result.Docs) == 0 {")
	g.addLine("\t\treturn nil, total, nil")
	g.addLine("\t}")
	g.addLine("\tids := make([]uint64, 0, len(result.Docs))")
	g.addLine("\tfor _, doc := range result.Docs {")
	g.addLine("\t\tid, err := strconv.ParseUint(strings.TrimPrefix(doc.ID, p.redisSearchPrefix), 10, 64)")
	g.addLine("\t\tif err != nil {")
	g.addLine("\t\t\treturn nil, total, err")
	g.addLine("\t\t}")
	g.addLine("\t\tids = append(ids, id)")
	g.addLine("\t}")
	g.addLine("\tentities, err := p.GetByIDs(ctx, ids...)")
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, total, err")
	g.addLine("\t}")
	g.addLine("\treturn entities, total, nil")
	g.addLine("}")
	g.addLine("")
}

func (g *codeGenerator) generateSearchIDsInRedis(schema *entitySchema, names *entityNames) {
	g.addImport("strings")
	g.addImport("strconv")
	g.addLine(fmt.Sprintf("func (p %s) SearchIDsInRedis(ctx fluxaorm.Context, where *fluxaorm.RedisSearchWhere, pager *fluxaorm.Pager) ([]uint64, error) {", names.providerNamePrivate))
	g.addLine("\toffset, count := 0, 10000")
	g.addLine("\tif pager != nil {")
	g.addLine("\t\toffset = (pager.CurrentPage - 1) * pager.PageSize")
	g.addLine("\t\tcount = pager.PageSize")
	g.addLine("\t}")
	g.addLine("\tresult, err := ctx.Engine().Redis(p.redisSearchCode).FTSearch(ctx, p.redisSearchIndex, where.String(), where.GetSearchOptions(offset, count))")
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, err")
	g.addLine("\t}")
	g.addLine("\tif len(result.Docs) == 0 {")
	g.addLine("\t\treturn nil, nil")
	g.addLine("\t}")
	g.addLine("\tids := make([]uint64, 0, len(result.Docs))")
	g.addLine("\tfor _, doc := range result.Docs {")
	g.addLine("\t\tid, err := strconv.ParseUint(strings.TrimPrefix(doc.ID, p.redisSearchPrefix), 10, 64)")
	g.addLine("\t\tif err != nil {")
	g.addLine("\t\t\treturn nil, err")
	g.addLine("\t\t}")
	g.addLine("\t\tids = append(ids, id)")
	g.addLine("\t}")
	g.addLine("\treturn ids, nil")
	g.addLine("}")
	g.addLine("")
}

func (g *codeGenerator) generateSearchIDsInRedisWithCount(schema *entitySchema, names *entityNames) {
	g.addImport("strings")
	g.addImport("strconv")
	g.addLine(fmt.Sprintf("func (p %s) SearchIDsInRedisWithCount(ctx fluxaorm.Context, where *fluxaorm.RedisSearchWhere, pager *fluxaorm.Pager) ([]uint64, int, error) {", names.providerNamePrivate))
	g.addLine("\tcountResult, err := ctx.Engine().Redis(p.redisSearchCode).FTSearch(ctx, p.redisSearchIndex, where.String(), where.GetSearchOptions(0, 0))")
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, 0, err")
	g.addLine("\t}")
	g.addLine("\ttotal := countResult.Total")
	g.addLine("\tif total == 0 {")
	g.addLine("\t\treturn nil, 0, nil")
	g.addLine("\t}")
	g.addLine("\toffset, count := 0, 10000")
	g.addLine("\tif pager != nil {")
	g.addLine("\t\toffset = (pager.CurrentPage - 1) * pager.PageSize")
	g.addLine("\t\tcount = pager.PageSize")
	g.addLine("\t}")
	g.addLine("\tresult, err := ctx.Engine().Redis(p.redisSearchCode).FTSearch(ctx, p.redisSearchIndex, where.String(), where.GetSearchOptions(offset, count))")
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, total, err")
	g.addLine("\t}")
	g.addLine("\tif len(result.Docs) == 0 {")
	g.addLine("\t\treturn nil, total, nil")
	g.addLine("\t}")
	g.addLine("\tids := make([]uint64, 0, len(result.Docs))")
	g.addLine("\tfor _, doc := range result.Docs {")
	g.addLine("\t\tid, err := strconv.ParseUint(strings.TrimPrefix(doc.ID, p.redisSearchPrefix), 10, 64)")
	g.addLine("\t\tif err != nil {")
	g.addLine("\t\t\treturn nil, total, err")
	g.addLine("\t\t}")
	g.addLine("\t\tids = append(ids, id)")
	g.addLine("\t}")
	g.addLine("\treturn ids, total, nil")
	g.addLine("}")
	g.addLine("")
}

func (g *codeGenerator) generateReindexRedisSearch(schema *entitySchema, names *entityNames) {
	g.addImport("strconv")
	g.addLine(fmt.Sprintf("func (p %s) ReindexRedisSearch(ctx fluxaorm.Context) error {", names.providerNamePrivate))

	// Step 1: delete all existing search hashes for this entity via Lua SCAN+UNLINK
	g.body += "\t_luaScript := `\n"
	g.body += "local cursor = '0'\n"
	g.body += "local deleted = 0\n"
	g.body += "repeat\n"
	g.body += "  local result = redis.call('SCAN', cursor, 'MATCH', KEYS[1], 'COUNT', 1000)\n"
	g.body += "  cursor = result[1]\n"
	g.body += "  local keys = result[2]\n"
	g.body += "  if #keys > 0 then\n"
	g.body += "    deleted = deleted + redis.call('UNLINK', unpack(keys))\n"
	g.body += "  end\n"
	g.body += "until cursor == '0'\n"
	g.body += "return deleted\n"
	g.body += "`\n"
	g.addLine("\t_, _err := ctx.Engine().Redis(p.redisSearchCode).Eval(ctx, _luaScript, []string{p.redisSearchPrefix + \"*\"})")
	g.addLine("\tif _err != nil {")
	g.addLine("\t\treturn _err")
	g.addLine("\t}")

	// Step 2: SELECT all columns from MySQL
	selectQuery := "\"SELECT `ID`"
	for _, columnName := range schema.GetColumns()[1:] {
		selectQuery += ",`" + columnName + "`"
	}
	selectQuery += fmt.Sprintf(" FROM `%s`\"", schema.tableName)
	g.addLine(fmt.Sprintf("\t_rows, _cl, _err := ctx.Engine().DB(p.dbCode).Query(ctx, %s)", selectQuery))
	g.addLine("\tif _err != nil {")
	g.addLine("\t\treturn _err")
	g.addLine("\t}")
	g.addLine("\tdefer _cl()")

	// Step 3: pipeline and row loop
	g.addLine(fmt.Sprintf("\t_pipeline := ctx.RedisPipeLine(p.redisSearchCode)"))
	g.addLine("\t_batchSize := 0")

	// Find FakeDelete field index if applicable
	fdIndex := -1
	if schema.hasFakeDelete {
		for i, cn := range schema.columnNames {
			if cn == "FakeDelete" {
				fdIndex = i
				break
			}
		}
	}

	searchFieldCap := len(schema.searchableFields) * 2

	g.addLine("\tfor _rows.Next() {")
	g.addLine(fmt.Sprintf("\t\t_sqlRow := &%s{}", names.sqlRowName))
	g.appendToLine(fmt.Sprintf("\t\tif _err = _rows.Scan(&_sqlRow.F0"))
	for i := 1; i < len(schema.columnNames); i++ {
		g.appendToLine(fmt.Sprintf(", &_sqlRow.F%d", i))
	}
	g.addLine("); _err != nil {")
	g.addLine("\t\t\treturn _err")
	g.addLine("\t\t}")

	if fdIndex >= 0 {
		g.addLine(fmt.Sprintf("\t\tif _sqlRow.F%d {", fdIndex))
		g.addLine("\t\t\tcontinue")
		g.addLine("\t\t}")
	}

	g.addLine("\t\t_key := p.redisSearchPrefix + strconv.FormatUint(_sqlRow.F0, 10)")
	g.addLine("\t\t_pipeline.Del(_key)")
	g.addLine(fmt.Sprintf("\t\t_sa := make([]any, 0, %d)", searchFieldCap))
	for _, f := range schema.searchableFields {
		g.body += g.searchHSetAppendFromVar(f, "\t\t", "_sa", "_sqlRow")
	}
	g.addLine("\t\tif len(_sa) > 0 {")
	g.addLine("\t\t\t_pipeline.HSet(_key, _sa...)")
	g.addLine("\t\t}")
	g.addLine("\t\t_batchSize++")
	g.addLine("\t\tif _batchSize >= 1000 {")
	g.addLine(fmt.Sprintf("\t\t\tif _, _err = _pipeline.Exec(ctx); _err != nil {"))
	g.addLine("\t\t\t\treturn _err")
	g.addLine("\t\t\t}")
	g.addLine(fmt.Sprintf("\t\t\t_pipeline = ctx.RedisPipeLine(p.redisSearchCode)"))
	g.addLine("\t\t\t_batchSize = 0")
	g.addLine("\t\t}")
	g.addLine("\t}")

	g.addLine("\tif _batchSize > 0 {")
	g.addLine(fmt.Sprintf("\t\tif _, _err = _pipeline.Exec(ctx); _err != nil {"))
	g.addLine("\t\t\treturn _err")
	g.addLine("\t\t}")
	g.addLine("\t}")
	g.addLine("\treturn nil")
	g.addLine("}")
	g.addLine("")
}

func (g *codeGenerator) generateSearchOne(schema *entitySchema, names *entityNames) {
	g.addImport("strings")
	g.addLine(fmt.Sprintf("func (p %s) SearchOne(ctx fluxaorm.Context, where fluxaorm.Where) (entity *%s, found bool, err error) {", names.providerNamePrivate, names.entityName))
	g.addLine("\tvar b strings.Builder")
	selectPrefix := "\"SELECT `ID`"
	for _, columnName := range schema.GetColumns()[1:] {
		selectPrefix += ",`" + columnName + "`"
	}
	selectPrefix += fmt.Sprintf(" FROM `%s`\"", schema.tableName)
	g.addLine(fmt.Sprintf("\tb.WriteString(%s)", selectPrefix))
	g.addLine("\tvar params []any")
	if schema.hasFakeDelete {
		g.addLine("\tvar whereStr string")
		g.addLine("\tif where != nil {")
		g.addLine("\t\twhereStr = where.String()")
		g.addLine("\t\tparams = where.GetParameters()")
		g.addLine("\t}")
		g.addLine("\tif whereStr != \"\" {")
		g.addLine("\t\tb.WriteString(\" WHERE \")")
		g.addLine("\t\tb.WriteString(whereStr)")
		g.addLine("\t}")
		g.addLine("\tif where == nil || !where.IsWithFakeDeletes() {")
		g.addLine("\t\tif whereStr != \"\" {")
		g.addLine("\t\t\tb.WriteString(\" AND `FakeDelete` = 0\")")
		g.addLine("\t\t} else {")
		g.addLine("\t\t\tb.WriteString(\" WHERE `FakeDelete` = 0\")")
		g.addLine("\t\t}")
		g.addLine("\t}")
	} else {
		g.addLine("\tif where != nil {")
		g.addLine("\t\tif w := where.String(); w != \"\" {")
		g.addLine("\t\t\tb.WriteString(\" WHERE \")")
		g.addLine("\t\t\tb.WriteString(w)")
		g.addLine("\t\t}")
		g.addLine("\t\tparams = where.GetParameters()")
		g.addLine("\t}")
	}
	g.addLine("\tb.WriteString(\" LIMIT 1\")")
	g.addLine(fmt.Sprintf("\tsqlRow := &%s{}", names.sqlRowName))
	g.appendToLine(fmt.Sprintf("\tfound, err = ctx.Engine().DB(%s.dbCode).QueryRow(ctx, fluxaorm.NewWhere(b.String(), params...), &sqlRow.F0", names.providerName))
	for i := 1; i < len(schema.columnNames); i++ {
		g.appendToLine(fmt.Sprintf(", &sqlRow.F%d", i))
	}
	g.addLine(")")
	g.addLine("\tif err != nil {")
	g.addLine("\t\treturn nil, false, err")
	g.addLine("\t}")
	g.addLine("\tif !found {")
	g.addLine("\t\treturn nil, false, nil")
	g.addLine("\t}")
	g.addLine(fmt.Sprintf("\treturn &%s{ctx: ctx, id: sqlRow.F0, originDatabaseValues: sqlRow}, true, nil", names.entityName))
	g.addLine("}")
	g.addLine("")
}
