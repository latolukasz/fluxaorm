package fluxaorm

import (
	"context"
	"testing"
	"time"

	"github.com/redis/go-redis/v9"

	"github.com/stretchr/testify/assert"
)

func TestRedis(t *testing.T) {
	registry := NewRegistry()
	registry.RegisterRedis("localhost:6385", 15, DefaultPoolCode, nil)
	validatedRegistry, err := registry.Validate()
	assert.Nil(t, err)
	orm := validatedRegistry.NewContext(context.Background())

	r := orm.Engine().Redis(DefaultPoolCode)

	testLogger := &MockLogHandler{}
	orm.RegisterQueryLogger(testLogger, false, true, false)
	err = r.FlushDB(orm)
	assert.NoError(t, err)
	testLogger.Clear()

	valid := false
	val, err := r.GetSet(orm, "test_get_set", time.Second*10, func() any {
		valid = true
		return "ok"
	})
	assert.NoError(t, err)
	assert.True(t, valid)
	assert.Equal(t, "ok", val)
	valid = false
	val, err = r.GetSet(orm, "test_get_set", time.Second*10, func() any {
		valid = true
		return "ok"
	})
	assert.NoError(t, err)
	assert.False(t, valid)
	assert.Equal(t, "ok", val)

	val, has, err := r.Get(orm, "test_get")
	assert.NoError(t, err)
	assert.False(t, has)
	assert.Equal(t, "", val)
	err = r.Set(orm, "test_get", "hello", 1*time.Second)
	assert.NoError(t, err)
	val, has, err = r.Get(orm, "test_get")
	assert.NoError(t, err)
	assert.True(t, has)
	assert.Equal(t, "hello", val)
	isSet, err := r.SetNX(orm, "test_get_nx", "hello nx", 1*time.Second)
	assert.NoError(t, err)
	assert.True(t, isSet)
	val, has, err = r.Get(orm, "test_get_nx")
	assert.NoError(t, err)
	assert.True(t, has)
	assert.Equal(t, "hello nx", val)
	isSet, err = r.SetNX(orm, "test_get_nx", "hello nx", 1*time.Second)
	assert.NoError(t, err)
	assert.False(t, isSet)

	_, err = r.LPush(orm, "test_list", "a")
	assert.NoError(t, err)
	l, err := r.LLen(orm, "test_list")
	assert.NoError(t, err)
	assert.Equal(t, int64(1), l)
	_, err = r.RPush(orm, "test_list", "b", "c")
	assert.NoError(t, err)
	l, err = r.LLen(orm, "test_list")
	assert.NoError(t, err)
	assert.Equal(t, int64(3), l)
	ls, err := r.LRange(orm, "test_list", 0, 2)
	assert.NoError(t, err)
	assert.Equal(t, []string{"a", "b", "c"}, ls)
	assert.NoError(t, err)
	ls, err = r.LRange(orm, "test_list", 1, 2)
	assert.NoError(t, err)
	assert.Equal(t, []string{"b", "c"}, ls)
	err = r.LSet(orm, "test_list", 1, "d")
	assert.NoError(t, err)
	ls, err = r.LRange(orm, "test_list", 0, 2)
	assert.NoError(t, err)
	assert.Equal(t, []string{"a", "d", "c"}, ls)
	err = r.LRem(orm, "test_list", 1, "c")
	_, err = r.LRange(orm, "test_list", 0, 2)
	assert.NoError(t, err)
	ls, err = r.LRange(orm, "test_list", 0, 2)
	assert.NoError(t, err)
	assert.Equal(t, []string{"a", "d"}, ls)

	val, has, err = r.RPop(orm, "test_list")
	assert.NoError(t, err)
	assert.True(t, has)
	assert.Equal(t, "d", val)
	err = r.Ltrim(orm, "test_list", 1, 2)
	assert.NoError(t, err)
	val, has, err = r.RPop(orm, "test_list")
	assert.NoError(t, err)
	assert.False(t, has)
	assert.Equal(t, "", val)

	err = r.HSet(orm, "test_map", "name", "Tom")
	assert.NoError(t, err)
	lM, err := r.HGetAll(orm, "test_map")
	assert.NoError(t, err)
	assert.Equal(t, map[string]string{"name": "Tom"}, lM)
	v, has, err := r.HGet(orm, "test_map", "name")
	assert.NoError(t, err)
	assert.True(t, has)
	assert.Equal(t, "Tom", v)
	_, has, err = r.HGet(orm, "test_map", "name2")
	assert.NoError(t, err)
	assert.False(t, has)

	err = r.HSet(orm, "test_map", "last", "Summer", "age", "16")
	assert.NoError(t, err)
	lM, err = r.HGetAll(orm, "test_map")
	assert.NoError(t, err)
	assert.Equal(t, map[string]string{"age": "16", "last": "Summer", "name": "Tom"}, lM)
	lMA, err := r.HMGet(orm, "test_map", "name", "age", "missing")
	assert.NoError(t, err)
	assert.Equal(t, map[string]any{"age": "16", "missing": nil, "name": "Tom"}, lMA)

	err = r.HDel(orm, "test_map", "age")
	assert.NoError(t, err)
	lM, err = r.HGetAll(orm, "test_map")
	assert.NoError(t, err)
	assert.Equal(t, map[string]string{"last": "Summer", "name": "Tom"}, lM)
	l, err = r.HLen(orm, "test_map")
	assert.NoError(t, err)
	assert.Equal(t, int64(2), l)

	b, err := r.HSetNx(orm, "test_map_nx", "key", "value")
	assert.NoError(t, err)
	assert.True(t, b)
	b, err = r.HSetNx(orm, "test_map_nx", "key", "value")
	assert.NoError(t, err)
	assert.False(t, b)

	val, err = r.HIncrBy(orm, "test_inc", "a", 2)
	assert.NoError(t, err)
	assert.Equal(t, int64(2), val)
	val, err = r.HIncrBy(orm, "test_inc", "a", 3)
	assert.NoError(t, err)
	assert.Equal(t, int64(5), val)

	val, err = r.IncrBy(orm, "test_inc_2", 2)
	assert.NoError(t, err)
	assert.Equal(t, int64(2), val)
	val, err = r.Incr(orm, "test_inc_2")
	assert.NoError(t, err)
	assert.Equal(t, int64(3), val)

	val, err = r.IncrWithExpire(orm, "test_inc_exp", time.Second)
	assert.NoError(t, err)
	assert.Equal(t, int64(1), val)
	val, err = r.IncrWithExpire(orm, "test_inc_exp", time.Second)
	assert.NoError(t, err)
	assert.Equal(t, int64(2), val)
	time.Sleep(time.Millisecond * 1200)
	val, err = r.IncrWithExpire(orm, "test_inc_exp", time.Second)
	assert.NoError(t, err)
	assert.Equal(t, int64(1), val)

	b, err = r.Expire(orm, "test_map", time.Second*1)
	assert.NoError(t, err)
	assert.True(t, b)
	l, err = r.Exists(orm, "test_map")
	assert.NoError(t, err)
	assert.Equal(t, int64(1), l)
	time.Sleep(time.Millisecond * 1200)
	l, err = r.Exists(orm, "test_map")
	assert.NoError(t, err)
	assert.Equal(t, int64(0), l)

	added, err := r.ZAdd(orm, "test_z", redis.Z{Member: "a", Score: 10}, redis.Z{Member: "b", Score: 20})
	assert.NoError(t, err)
	assert.Equal(t, int64(2), added)
	sl, err := r.ZRevRange(orm, "test_z", 0, 3)
	assert.NoError(t, err)
	assert.Equal(t, []string{"b", "a"}, sl)
	f, err := r.ZScore(orm, "test_z", "a")
	assert.NoError(t, err)
	assert.Equal(t, float64(10), f)
	resZRange, err := r.ZRangeWithScores(orm, "test_z", 0, 3)
	assert.NoError(t, err)
	assert.Len(t, resZRange, 2)
	assert.Equal(t, "a", resZRange[0].Member)
	assert.Equal(t, "b", resZRange[1].Member)
	assert.Equal(t, float64(10), resZRange[0].Score)
	assert.Equal(t, float64(20), resZRange[1].Score)
	resZRange, err = r.ZRevRangeWithScores(orm, "test_z", 0, 3)
	assert.NoError(t, err)
	assert.Len(t, resZRange, 2)
	assert.Equal(t, "b", resZRange[0].Member)
	assert.Equal(t, "a", resZRange[1].Member)
	assert.Equal(t, float64(20), resZRange[0].Score)
	assert.Equal(t, float64(10), resZRange[1].Score)

	l, err = r.ZCard(orm, "test_z")
	assert.NoError(t, err)
	assert.Equal(t, int64(2), l)
	l, err = r.ZCount(orm, "test_z", "10", "20")
	assert.NoError(t, err)
	assert.Equal(t, int64(2), l)
	l, err = r.ZCount(orm, "test_z", "11", "20")
	assert.NoError(t, err)
	assert.Equal(t, int64(1), l)
	err = r.Del(orm, "test_z")
	assert.NoError(t, err)
	assert.Equal(t, int64(1), l)
	l, err = r.ZCount(orm, "test_z", "10", "20")
	assert.Equal(t, int64(0), l)
	err = r.Del(orm, "test_z")
	assert.NoError(t, err)
	assert.Equal(t, int64(0), l)

	err = r.MSet(orm, "key_1", "a", "key_2", "b")
	assert.NoError(t, err)
	list, err := r.MGet(orm, "key_1", "key_2", "missing")
	assert.NoError(t, err)
	assert.Equal(t, []any{"a", "b", nil}, list)

	added, err = r.SAdd(orm, "test_s", "a", "b", "c", "d", "a")
	assert.NoError(t, err)
	assert.Equal(t, int64(4), added)
	l, err = r.SCard(orm, "test_s")
	assert.NoError(t, err)
	assert.Equal(t, int64(4), l)
	val, has, err = r.SPop(orm, "test_s")
	assert.NoError(t, err)
	assert.NotEqual(t, "", val)
	assert.True(t, has)
	sl, err = r.SPopN(orm, "test_s", 10)
	assert.NoError(t, err)
	assert.Len(t, sl, 3)
	sl, err = r.SPopN(orm, "test_s", 10)
	assert.Len(t, sl, 0)
	val, has, err = r.SPop(orm, "test_s")
	assert.NoError(t, err)
	assert.Equal(t, "", val)
	assert.False(t, has)

	script := `
		local count = 2	
		return count + KEYS[1] + ARGV[1]
	`
	val, err = r.Eval(orm, script, []string{"3"}, 7)
	assert.NoError(t, err)
	assert.Equal(t, int64(12), val)
	val, err = r.ScriptLoad(orm, script)
	assert.NoError(t, err)

	b, err = r.ScriptExists(orm, "invalid")
	assert.NoError(t, err)
	assert.False(t, b)
	b, err = r.ScriptExists(orm, "618358a5df682faed583025e34f07905c2a96823")
	assert.NoError(t, err)
	assert.True(t, b)

	assert.Equal(t, "618358a5df682faed583025e34f07905c2a96823", val)
	val, exists, err := r.EvalSha(orm, val.(string), []string{"3"}, 8)
	assert.NoError(t, err)
	assert.Equal(t, int64(13), val)
	assert.True(t, exists)

	val, exists, err = r.EvalSha(orm, "invalid", []string{"3"}, 8)
	assert.NoError(t, err)
	assert.Nil(t, val)
	assert.False(t, exists)

	err = r.Set(orm, "a", "n", 10*time.Second)
	assert.NoError(t, err)
	err = r.FlushAll(orm)
	assert.NoError(t, err)
	l, err = r.Exists(orm, "a")
	assert.NoError(t, err)
	assert.Equal(t, int64(0), l)

	res, err := r.Info(orm)
	assert.NoError(t, err)
	assert.Contains(t, res, "redis_version")

	_, err = r.LPush(orm, "test_list", "test")
	assert.NoError(t, err)
	has, _ = orm.getRedisLoggers()
	st, err := r.Type(orm, "test_list")
	assert.NoError(t, err)
	assert.Equal(t, "list", st)

	val, err = r.LMove(orm, "test_list", "test_list_next", "RIGHT", "LEFT")
	assert.NoError(t, err)
	assert.Equal(t, "test", val)
	val, err = r.BLMove(orm, "test_list_next", "test_list", "RIGHT", "LEFT", time.Second)
	assert.NoError(t, err)
	assert.Equal(t, "test", val)
	_, err = r.SAdd(orm, "test_set", "test", "value")
	assert.NoError(t, err)
	b, err = r.SIsMember(orm, "test_set", "test")
	assert.NoError(t, err)
	assert.True(t, b)

	registry = NewRegistry()
	registry.RegisterRedis("localhost:6385", 15, DefaultPoolCode, &RedisOptions{User: "user", Password: "pass"})
	validatedRegistry, err = registry.Validate()
	assert.Error(t, err, "WRONGPASS invalid username-password pair or user is disabled.")
}
